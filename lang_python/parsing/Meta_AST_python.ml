(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open AST_python


let vof_tok v = Meta_parse_info.vof_info_adjustable_precision v
  
let vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_tok v2 in OCaml.VTuple [ v1; v2 ]

let vof_bracket of_a (_t1, x, _t2) =
  of_a x
  
let vof_name v = vof_wrap OCaml.vof_string v
  
let vof_dotted_name v = OCaml.vof_list vof_name v

let vof_module_name (v1, v2) = 
  let v1 = vof_dotted_name v1
  and v2 = OCaml.vof_option (OCaml.vof_list vof_tok) v2 in
  OCaml.VTuple [v1; v2]

let vof_resolved_name =
  function
  | LocalVar -> OCaml.VSum (("LocalVar", []))
  | Parameter -> OCaml.VSum (("Parameter", []))
  | GlobalVar -> OCaml.VSum (("GlobalVar", []))
  | ClassField -> OCaml.VSum (("ClassField", []))
  | ImportedModule v1 ->
      let v1 = vof_dotted_name v1 in OCaml.VSum (("ImportedModule", [ v1 ]))
  | ImportedEntity v1 ->
      let v1 = vof_dotted_name v1 in OCaml.VSum (("ImportedEntity", [ v1 ]))
  | NotResolved -> OCaml.VSum (("NotResolved", []))
  
let rec vof_expr =
  function
  | Num v1 -> let v1 = vof_number v1 in OCaml.VSum (("Num", [ v1 ]))
  | Str v1 ->
      let v1 = (vof_wrap OCaml.vof_string) v1
      in OCaml.VSum (("Str", [ v1 ]))
  | EncodedStr ((v1, v2)) ->
      let v1 = (vof_wrap OCaml.vof_string) v1
      and v2 = OCaml.vof_string v2
      in OCaml.VSum (("EncodedStr", [ v1; v2 ]))
  | InterpolatedString v1 ->
      let v1 = OCaml.vof_list vof_expr v1 in
      OCaml.VSum (("InterpolatedString", [v1]))
  | ConcatenatedString v1 ->
      let v1 = OCaml.vof_list vof_expr v1 in
      OCaml.VSum (("ConcatenatedString", [v1]))
  | Bool v1 ->
      let v1 = vof_wrap OCaml.vof_bool v1 in OCaml.VSum (("Bool", [ v1 ]))
  | None_ v1 -> let v1 = vof_tok v1 in OCaml.VSum (("None_", [ v1 ]))
  | Name ((v1, v2, v3)) ->
      let v1 = vof_name v1
      and v2 = vof_expr_context v2
      and v3 = OCaml.vof_ref vof_resolved_name v3
      in OCaml.VSum (("Name", [ v1; v2; v3 ]))
  | Tuple ((v1, v2)) ->
      let v1 = vof_list_or_comprehension vof_expr v1
      and v2 = vof_expr_context v2
      in OCaml.VSum (("Tuple", [ v1; v2 ]))
  | List ((v1, v2)) ->
      let v1 = vof_list_or_comprehension vof_expr v1
      and v2 = vof_expr_context v2
      in OCaml.VSum (("List", [ v1; v2 ]))
  | DictOrSet v1 ->
      let v1 = vof_list_or_comprehension2 vof_dictorset_elt v1
      in OCaml.VSum (("DictOrSet", [ v1 ]))
  | ExprStar v1 -> let v1 = vof_expr v1 in OCaml.VSum (("ExprStar", [ v1 ]))
  | TypedExpr ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_type_ v2
      in OCaml.VSum (("TypedExpr", [ v1; v2 ]))
  | Ellipsis v1 -> let v1 = vof_tok v1 in OCaml.VSum (("Ellipsis", [ v1 ]))
  | DeepEllipsis v1 -> let v1 = vof_bracket vof_expr v1 in 
      OCaml.VSum (("DeepEllipsis", [ v1 ]))
  | TypedMetavar ((v1, v2, v3)) ->
      let v1 = vof_name v1
      and v2 = vof_tok v2
      and v3 = vof_type_ v3
      in OCaml.VSum (("TypedMetavar", [ v1; v2; v3 ]))
  | BoolOp ((v1, v2)) ->
      let v1 = vof_wrap vof_boolop v1
      and v2 = OCaml.vof_list vof_expr v2
      in OCaml.VSum (("BoolOp", [ v1; v2 ]))
  | BinOp ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_operator v2
      and v3 = vof_expr v3
      in OCaml.VSum (("BinOp", [ v1; v2; v3 ]))
  | UnaryOp ((v1, v2)) ->
      let v1 = vof_wrap vof_unaryop v1
      and v2 = vof_expr v2
      in OCaml.VSum (("UnaryOp", [ v1; v2 ]))
  | Compare ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list (vof_wrap vof_cmpop) v2
      and v3 = OCaml.vof_list vof_expr v3
      in OCaml.VSum (("Compare", [ v1; v2; v3 ]))
  | Call ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_argument v2
      in OCaml.VSum (("Call", [ v1; v2 ]))
  | Subscript ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_slice v2
      and v3 = vof_expr_context v3
      in OCaml.VSum (("Subscript", [ v1; v2; v3 ]))
  | Lambda ((v1, v2)) ->
      let v1 = vof_parameters v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Lambda", [ v1; v2 ]))
  | IfExp ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in OCaml.VSum (("IfExp", [ v1; v2; v3 ]))
  | Yield ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1
      and v2 = OCaml.vof_bool v2
      in OCaml.VSum (("Yield", [ t; v1; v2 ]))
  | Await (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in OCaml.VSum (("Await", [ t; v1 ]))
  | Repr (v1) -> 
      let v1 = vof_bracket vof_expr v1 in OCaml.VSum (("Repr", [ v1 ]))
  | Attribute ((v1, t, v2, v3)) ->
      let v1 = vof_expr v1
      and t = vof_tok t
      and v2 = vof_name v2
      and v3 = vof_expr_context v3
      in OCaml.VSum (("Attribute", [ v1; t; v2; v3 ]))
  | NamedExpr (v, t, e) ->
      let v = vof_expr v and t = vof_tok t and e = vof_expr e
      in OCaml.VSum (("NamedExpr", [ v; t; e ]))
and vof_number =
  function
  | Int v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Int", [ v1 ]))
  | LongInt v1 ->
      let v1 = vof_wrap OCaml.vof_string v1
      in OCaml.VSum (("LongInt", [ v1 ]))
  | Float v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Float", [ v1 ]))
  | Imag v1 ->
      let v1 = vof_wrap OCaml.vof_string v1 in OCaml.VSum (("Imag", [ v1 ]))
and vof_boolop =
  function | And -> OCaml.VSum (("And", [])) | Or -> OCaml.VSum (("Or", []))
and vof_operator =
  function
  | Add -> OCaml.VSum (("Add", []))
  | Sub -> OCaml.VSum (("Sub", []))
  | Mult -> OCaml.VSum (("Mult", []))
  | Div -> OCaml.VSum (("Div", []))
  | Mod -> OCaml.VSum (("Mod", []))
  | Pow -> OCaml.VSum (("Pow", []))
  | MatMult -> OCaml.VSum (("MatMult", []))
  | FloorDiv -> OCaml.VSum (("FloorDiv", []))
  | LShift -> OCaml.VSum (("LShift", []))
  | RShift -> OCaml.VSum (("RShift", []))
  | BitOr -> OCaml.VSum (("BitOr", []))
  | BitXor -> OCaml.VSum (("BitXor", []))
  | BitAnd -> OCaml.VSum (("BitAnd", []))
and vof_unaryop =
  function
  | Invert -> OCaml.VSum (("Invert", []))
  | Not -> OCaml.VSum (("Not", []))
  | UAdd -> OCaml.VSum (("UAdd", []))
  | USub -> OCaml.VSum (("USub", []))
and vof_cmpop =
  function
  | Eq -> OCaml.VSum (("Eq", []))
  | NotEq -> OCaml.VSum (("NotEq", []))
  | Lt -> OCaml.VSum (("Lt", []))
  | LtE -> OCaml.VSum (("LtE", []))
  | Gt -> OCaml.VSum (("Gt", []))
  | GtE -> OCaml.VSum (("GtE", []))
  | Is -> OCaml.VSum (("Is", []))
  | IsNot -> OCaml.VSum (("IsNot", []))
  | In -> OCaml.VSum (("In", []))
  | NotIn -> OCaml.VSum (("NotIn", []))

and vof_list_or_comprehension _of_a =
  function
  | CompList v1 ->
      let v1 = vof_bracket (OCaml.vof_list _of_a) v1 in 
      OCaml.VSum (("CompList", [ v1 ]))
  | CompForIf v1 ->
      let v1 = vof_comprehension _of_a v1
      in OCaml.VSum (("CompForIf", [ v1 ]))
and vof_list_or_comprehension2 _of_a =
  function
  | CompList v1 ->
      let v1 = vof_bracket (OCaml.vof_list _of_a) v1 in 
      OCaml.VSum (("CompList", [ v1 ]))
  | CompForIf v1 ->
      let v1 = vof_comprehension2 _of_a v1
      in OCaml.VSum (("CompForIf", [ v1 ]))
and vof_comprehension2 _of_a (v1, v2) =
  let v1 = _of_a v1
  and v2 = OCaml.vof_list vof_for_if v2
  in OCaml.VTuple [ v1; v2 ]
and vof_comprehension _of_a (v1, v2) =
  let v1 = _of_a v1
  and v2 = OCaml.vof_list vof_for_if v2
  in OCaml.VTuple [ v1; v2 ]
and vof_for_if =
  function
  | CompFor ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("CompFor", [ v1; v2 ]))
  | CompIf v1 -> let v1 = vof_expr v1 in OCaml.VSum (("CompIf", [ v1 ]))
and vof_dictorset_elt =
  function
  | KeyVal ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("KeyVal", [ v1; v2 ]))
  | Key v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Key", [ v1 ]))
  | PowInline v1 ->
      let v1 = vof_expr v1 in OCaml.VSum (("PowInline", [ v1 ]))
and vof_expr_context =
  function
  | Load -> OCaml.VSum (("Load", []))
  | Store -> OCaml.VSum (("Store", []))
  | Del -> OCaml.VSum (("Del", []))
  | AugLoad -> OCaml.VSum (("AugLoad", []))
  | AugStore -> OCaml.VSum (("AugStore", []))
  | Param -> OCaml.VSum (("Param", []))
and vof_slice =
  function
  | Slice ((v1, v2, v3)) ->
      let v1 = OCaml.vof_option vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      and v3 = OCaml.vof_option vof_expr v3
      in OCaml.VSum (("Slice", [ v1; v2; v3 ]))
  | Index v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Index", [ v1 ]))
and vof_parameters v = OCaml.vof_list vof_parameter v
and vof_parameter =
  function
  | ParamSingleStar v1 -> let v1 = vof_tok v1 
    in OCaml.VSum (("ParamSingleStar", [ v1 ]))
  | ParamEllipsis v1 -> let v1 = vof_tok v1 
    in OCaml.VSum (("ParamEllipsis", [ v1 ]))
  | ParamClassic ((v1, v2)) ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_name v1
             and v2 = OCaml.vof_option vof_type_ v2
             in OCaml.VTuple [ v1; v2 ])
      and v2 = OCaml.vof_option vof_expr v2
      in OCaml.VSum (("ParamClassic", [ v1; v2 ]))
  | ParamStar v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_name v1
             and v2 = OCaml.vof_option vof_type_ v2
             in OCaml.VTuple [ v1; v2 ])
      in OCaml.VSum (("ParamStar", [ v1 ]))
  | ParamPow v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_name v1
             and v2 = OCaml.vof_option vof_type_ v2
             in OCaml.VTuple [ v1; v2 ])
      in OCaml.VSum (("ParamPow", [ v1 ]))
and vof_argument =
  function
  | Arg v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Arg", [ v1 ]))
  | ArgKwd ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = vof_expr v2
      in OCaml.VSum (("ArgKwd", [ v1; v2 ]))
  | ArgStar v1 -> let v1 = vof_expr v1 in OCaml.VSum (("ArgStar", [ v1 ]))
  | ArgPow v1 -> let v1 = vof_expr v1 in OCaml.VSum (("ArgPow", [ v1 ]))
  | ArgComp ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_for_if v2
      in OCaml.VSum (("ArgComp", [ v1; v2 ]))
and vof_type_ v = vof_expr v
and vof_type_parent v = vof_argument v
  
let vof_pattern v = vof_expr v
  
let rec vof_stmt =
  function
  | ExprStmt v1 -> let v1 = vof_expr v1 in OCaml.VSum (("ExprStmt", [ v1 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = OCaml.vof_list vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in OCaml.VSum (("Assign", [ v1; v2; v3 ]))
  | AugAssign ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_operator v2
      and v3 = vof_expr v3
      in OCaml.VSum (("AugAssign", [ v1; v2; v3 ]))
  | For ((t, v1, t2, v2, v3, v4)) ->
      let t = vof_tok t in
      let v1 = vof_pattern v1 in
      let t2 = vof_tok t2
      and v2 = vof_expr v2
      and v3 = OCaml.vof_list vof_stmt v3
      and v4 = OCaml.vof_list vof_stmt v4
      in OCaml.VSum (("For", [ t; v1; t2; v2; v3; v4 ]))
  | While ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_stmt v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("While", [ t; v1; v2; v3 ]))
  | If ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_stmt v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("If", [ t; v1; v2; v3 ]))
  | With ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("With", [ t; v1; v2; v3 ]))
  | Return (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1
      in OCaml.VSum (("Return", [ t; v1 ]))
  | Break t -> 
      let t = vof_tok t in
      OCaml.VSum (("Break", [t]))
  | Continue t -> 
      let t = vof_tok t in
      OCaml.VSum (("Continue", [t]))
  | Pass t -> 
      let t = vof_tok t in
      OCaml.VSum (("Pass", [t]))
  | Raise (t, v1) ->
      let t = vof_tok t in
      let v1 =
        OCaml.vof_option
          (fun (v1, v2) ->
             let v1 = vof_expr v1
             and v2 = OCaml.vof_option vof_expr v2
             in OCaml.VTuple [ v1; v2 ])
          v1
      in OCaml.VSum (("Raise", [ t; v1 ]))
  | TryExcept ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_stmt v1
      and v2 = OCaml.vof_list vof_excepthandler v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("TryExcept", [ t; v1; v2; v3 ]))
  | TryFinally ((t, v1, t2, v2)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_stmt v1 in
      let t2 = vof_tok t2 in
      let v2 = OCaml.vof_list vof_stmt v2 in
      OCaml.VSum (("TryFinally", [ t; v1; t2; v2 ]))
  | Assert ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      in OCaml.VSum (("Assert", [ t; v1; v2 ]))
  | Global (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_name v1 in OCaml.VSum (("Global", [ t; v1 ]))
  | Delete (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_expr v1 in OCaml.VSum (("Delete", [ t; v1 ]))
  | NonLocal (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_name v1
      in OCaml.VSum (("NonLocal", [ t; v1 ]))
  | Async (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_stmt v1 in OCaml.VSum (("Async", [ t; v1 ]))
  | ImportAs (t, v1, v2) ->
      let t = vof_tok t in
      let v1 = vof_alias_dotted (v1, v2)
      in OCaml.VSum (("ImportAs", [ t; v1 ]))
  | ImportAll (t, v1, v2) ->
      let t = vof_tok t in
      let v1 = vof_module_name v1
      and v2 = vof_tok v2
      in OCaml.VSum (("ImportAll", [t; v1; v2]))
  | ImportFrom ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_module_name v1
      and v2 = OCaml.vof_list vof_alias v2
      in OCaml.VSum (("ImportFrom", [ t; v1; v2 ]))

  | FunctionDef ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_name v1
      and v2 = vof_parameters v2
      and v3 = OCaml.vof_option vof_type_ v3
      and v4 = OCaml.vof_list vof_stmt v4
      and v5 = OCaml.vof_list vof_decorator v5
      in OCaml.VSum (("FunctionDef", [ v1; v2; v3; v4; v5 ]))
  | ClassDef ((v1, v2, v3, v4)) ->
      let v1 = vof_name v1
      and v2 = OCaml.vof_list vof_type_parent v2
      and v3 = OCaml.vof_list vof_stmt v3
      and v4 = OCaml.vof_list vof_decorator v4
      in OCaml.VSum (("ClassDef", [ v1; v2; v3; v4 ]))
  | Exec ((v0, v1, v2, v3)) ->
      let v0 = vof_tok v0 in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      and v3 = OCaml.vof_option vof_expr v3
      in OCaml.VSum (("Exec", [ v0; v1; v2; v3 ]))
 | Print ((v0, v1, v2, v3)) ->
      let v0 = vof_tok v0 in
      let v1 = OCaml.vof_option vof_expr v1
      and v2 = OCaml.vof_list vof_expr v2
      and v3 = OCaml.vof_bool v3
      in OCaml.VSum (("Print", [ v0; v1; v2; v3 ]))

and vof_excepthandler =
  function
  | ExceptHandler ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_type_ v1
      and v2 = OCaml.vof_option vof_name v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("ExceptHandler", [ t; v1; v2; v3 ]))
and vof_decorator v = vof_expr v
and vof_alias (v1, v2) =
  let v1 = vof_name v1
  and v2 = OCaml.vof_option vof_name v2
  in OCaml.VTuple [ v1; v2 ]
and vof_alias_dotted (v1, v2) =
  let v1 = vof_module_name v1
  and v2 = OCaml.vof_option vof_name v2
  in OCaml.VTuple [ v1; v2 ]
  
let vof_program v = OCaml.vof_list vof_stmt v
  
let vof_any =
  function
  | Expr v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Expr", [ v1 ]))
  | Stmt v1 -> let v1 = vof_stmt v1 in OCaml.VSum (("Stmt", [ v1 ]))
  | Stmts v1 ->
      let v1 = OCaml.vof_list vof_stmt v1 in OCaml.VSum (("Stmts", [ v1 ]))
  | Program v1 -> let v1 = vof_program v1 in OCaml.VSum (("Program", [ v1 ]))
  | DictElem v1 ->
      let v1 = vof_dictorset_elt v1 in OCaml.VSum (("DictElem", [ v1 ]))
  
