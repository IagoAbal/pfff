(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast_php
module Ast_php = Meta_cst_php

(* very very ugly *)
let visit_mode = ref false
let visited_toks = ref []

let vof_tok x = Meta_parse_info.vof_info_adjustable_precision x

let vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_tok v2 in OCaml.VTuple [ v1; v2 ]

let vof_bracket of_a (_t1, x, _t2) =
  of_a x

let rec vof_program v = OCaml.vof_list vof_stmt v

and vof_wrapped_string (s, tok) =
  if !visit_mode
  then visited_toks := tok :: !visited_toks;
  vof_wrap OCaml.vof_string (s, tok)

and vof_name x = OCaml.vof_list vof_wrapped_string x
and vof_qualified_ident x = OCaml.vof_list vof_wrapped_string x
and vof_ident x = vof_wrapped_string x
and vof_var x = vof_wrapped_string x

and vof_stmt =
  function
  | Expr v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Expr", [ v1 ]))
  | Block v1 ->
      let v1 = OCaml.vof_list vof_stmt v1 in OCaml.VSum (("Block", [ v1 ]))
  | If ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("If", [ t; v1; v2; v3 ]))
  | While ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_stmt v2
      in OCaml.VSum (("While", [ t; v1; v2 ]))
  | Do ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_stmt v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Do", [ t; v1; v2 ]))
  | For ((t, v1, v2, v3, v4)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_expr v1
      and v2 = OCaml.vof_list vof_expr v2
      and v3 = OCaml.vof_list vof_expr v3
      and v4 = OCaml.vof_list vof_stmt v4
      in OCaml.VSum (("For", [ t; v1; v2; v3; v4 ]))
  | Switch ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_case v2
      in OCaml.VSum (("Switch", [ t; v1; v2 ]))
  | Foreach ((t, v1, t2, v2, v3)) ->
      let t = vof_tok t in
      let t2 = vof_tok t2 in
      let v1 = vof_expr v1
      and v2 = vof_pattern v2
      and v3 = OCaml.vof_list vof_stmt v3
      in OCaml.VSum (("Foreach", [ t; v1; t2; v2; v3 ]))
  | Return (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1
      in OCaml.VSum (("Return", [ t; v1 ]))
  | Break (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1 in OCaml.VSum (("Break", [ t; v1 ]))
  | Continue (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_option vof_expr v1
      in OCaml.VSum (("Continue", [ t; v1 ]))
  | Throw (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in OCaml.VSum (("Throw", [ t; v1 ]))
  | Try ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_stmt v1
      and v2 = OCaml.vof_list vof_catch v2
      and v3 = OCaml.vof_list vof_finally v3
      in OCaml.VSum (("Try", [ t; v1; v2; v3 ]))
  | StaticVars (t, v1) ->
      let t = vof_tok t in
      let v1 =
        OCaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_wrapped_string v1
             and v2 = OCaml.vof_option vof_expr v2
             in OCaml.VTuple [ v1; v2 ])
          v1
      in OCaml.VSum (("StaticVars", [ t; v1 ]))
  | Global (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_expr v1 in OCaml.VSum (("Global", [ t; v1 ]))
  | ClassDef v1 ->
      let v1 = vof_class_def v1 in OCaml.VSum (("ClassDef", [ v1 ]))
  | FuncDef v1 ->
      let v1 = vof_func_def v1 in OCaml.VSum (("FuncDef", [ v1 ]))
  | ConstantDef v1 ->
      let v1 = vof_constant_def v1 in OCaml.VSum (("ConstantDef", [ v1 ]))
  | TypeDef v1 ->
      let v1 = vof_type_def v1 in OCaml.VSum (("TypeDef", [ v1 ]))
  | NamespaceDef (t, v1, v2) ->
      let t = vof_tok t in
      let v1 = vof_qualified_ident v1 in
      let v2 = vof_bracket (OCaml.vof_list vof_stmt) v2  in
      OCaml.VSum (("NamespaceDef", [ t; v1; v2 ]))
  | NamespaceUse ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_qualified_ident v1
      and v2 = OCaml.vof_option vof_ident v2
      in OCaml.VSum (("NamespaceUse", [ t; v1; v2 ]))


and vof_type_def { t_name = v_t_name; t_kind = v_t_kind } =
  let bnds = [] in
  let arg = vof_type_def_kind v_t_kind in
  let bnd = ("t_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_t_name in
  let bnd = ("t_name", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_type_def_kind =
  function
  | Alias v1 -> let v1 = vof_hint_type v1 in OCaml.VSum (("Alias", [ v1 ]))
  | Newtype v1 ->
      let v1 = vof_hint_type v1 in OCaml.VSum (("Newtype", [ v1 ]))
  | ClassConstType v1 ->
      let v1 = OCaml.vof_option vof_hint_type v1 in
        OCaml.VSum (("ClassConstType", [v1]))

and vof_case =
  function
  | Case ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_stmt v2
      in OCaml.VSum (("Case", [ t; v1; v2 ]))
  | Default (t, v1) ->
      let t = vof_tok t in
      let v1 = OCaml.vof_list vof_stmt v1 in 
      OCaml.VSum (("Default", [ t; v1 ]))
and vof_catch (t, v1, v2, v3) =
  let t = vof_tok t in 
  let v1 = vof_hint_type v1
  and v2 = vof_var v2
  and v3 = OCaml.vof_list vof_stmt v3
  in OCaml.VTuple [ t; v1; v2; v3 ]
and vof_finally (t, v1) =
  let t = vof_tok t in 
  let v1 = OCaml.vof_list vof_stmt v1
  in OCaml.VTuple [ t; v1 ]
and vof_expr =
  function
  | Int v1 -> let v1 = vof_wrapped_string v1 in OCaml.VSum (("Int", [ v1 ]))
  | Double v1 ->
      let v1 = vof_wrapped_string v1 in OCaml.VSum (("Double", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrapped_string v1 in OCaml.VSum (("String", [ v1 ]))
  | Guil v1 ->
      let v1 = vof_bracket (OCaml.vof_list vof_encaps) v1 in 
      OCaml.VSum (("Guil", [ v1 ]))
  | Id v1 ->
      let v1 = vof_name v1 in OCaml.VSum (("Id", [ v1 ]))
  | IdSpecial v1 ->
      let v1 = vof_wrap vof_special v1 in OCaml.VSum (("IdSpecial", [ v1 ]))
  | Var v1 ->
      let v1 = vof_var v1 in OCaml.VSum (("Var", [ v1 ]))
  | Array_get ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_option vof_expr v2
      in OCaml.VSum (("Array_get", [ v1; v2 ]))
  | Obj_get ((v1, t, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Obj_get", [ v1; t; v2 ]))
  | Class_get ((v1, t, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Class_get", [ v1; t; v2 ]))
  | Assign ((v1, t, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v3 = vof_expr v3
      in OCaml.VSum (("Assign", [ v1; t; v3 ]))
  | AssignOp ((v1, v2, v3)) ->
      let v2 = vof_wrap vof_binaryOp v2
      and v1 = vof_expr v1
      and v3 = vof_expr v3
      in OCaml.VSum (("AssignOp", [ v1; v2; v3 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_wrap Ast_php.vof_fixOp v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Infix", [ v1; v2 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_wrap Ast_php.vof_fixOp v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Postfix", [ v1; v2 ]))
  | Binop ((v1, v2, v3)) ->
      let v2 = vof_wrap vof_binaryOp v2
      and v1 = vof_expr v1
      and v3 = vof_expr v3
      in OCaml.VSum (("Binop", [ v1; v2; v3 ]))
  | Unop ((v1, v2)) ->
      let v1 = vof_wrap vof_unaryOp v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Unop", [ v1; v2 ]))
  | Call ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_expr v2
      in OCaml.VSum (("Call", [ v1; v2 ]))
  | Ref (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in OCaml.VSum (("Ref", [ t; v1 ]))
  | Unpack v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Unpack", [ v1 ]))
  | Xhp v1 -> let v1 = vof_xml v1 in OCaml.VSum (("Xhp", [ v1 ]))
  | ConsArray (v1) ->
      let v1 = vof_bracket (OCaml.vof_list vof_array_value) v1
      in OCaml.VSum (("ConsArray", [ v1 ]))
  | Collection (v1, v2) ->
      let v1 = vof_name v1 in
      let v2 = vof_bracket (OCaml.vof_list vof_array_value) v2 in
      OCaml.VSum (("Collection", [ v1 ; v2 ]))
  | List v1 ->
      let v1 = vof_bracket (OCaml.vof_list vof_expr) v1 in 
      OCaml.VSum (("List", [ v1 ]))
  | Arrow ((v1, t, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Arrow", [ v1; t; v2 ]))
  | New ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = OCaml.vof_list vof_expr v2
      in OCaml.VSum (("New", [ t; v1; v2 ]))
  | InstanceOf ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in OCaml.VSum (("InstanceOf", [ t; v1; v2 ]))
  | CondExpr ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in OCaml.VSum (("CondExpr", [ v1; v2; v3 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_wrap Ast_php.vof_ptype v1
      and v2 = vof_expr v2
      in OCaml.VSum (("Cast", [ v1; v2 ]))
  | Lambda v1 -> let v1 = vof_func_def v1 in OCaml.VSum (("Lambda", [ v1 ]))
and vof_encaps x = vof_expr x
and vof_xhp =
  function
  | XhpText v1 ->
      let v1 = vof_wrapped_string v1 in OCaml.VSum (("XhpText", [ v1 ]))
  | XhpExpr v1 -> 
      let v1 = vof_expr v1 in OCaml.VSum (("XhpExpr", [ v1 ]))
  | XhpXml v1 -> 
      let v1 = vof_xml v1 in OCaml.VSum (("XhpXml", [ v1 ]))
and
  vof_xml {
            xml_tag = v_xml_tag;
            xml_attrs = v_xml_attrs;
            xml_body = v_xml_body
          } =
  let bnds = [] in
  let arg = OCaml.vof_list vof_xhp v_xml_body in
  let bnd = ("xml_body", arg) in
  let bnds = bnd :: bnds in
  let arg =
    OCaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_var v1
         and v2 = vof_xhp_attr v2
         in OCaml.VTuple [ v1; v2 ])
      v_xml_attrs in
  let bnd = ("xml_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_xml_tag in
  let bnd = ("xml_tag", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_xhp_attr x = vof_expr x

and vof_special = function
  | This -> OCaml.VSum (("This", [ ]))
  | Eval -> OCaml.VSum (("Eval", [ ]))

and vof_binaryOp = function
 | BinaryConcat -> OCaml.VSum ("BinaryConcat", [])
 | CombinedComparison  -> OCaml.VSum ("BinaryConcat", [])
 | ArithOp v1 -> 
      let v1 = Meta_ast_generic_common.vof_arithmetic_operator v1 in
      OCaml.VSum ("ArithOp", [v1])

and vof_unaryOp = 
  Meta_ast_generic_common.vof_arithmetic_operator

and vof_constant_def { cst_name = v_cst_name; cst_body = v_cst_body; cst_tok = tok } =
  let bnds = [] in
  let arg =  vof_tok tok in
  let bnd = ("cst_tok", arg) in
  let bnds = bnd :: bnds in
  let arg =  OCaml.vof_option vof_expr v_cst_body in
  let bnd = ("cst_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrapped_string v_cst_name in
  let bnd = ("cst_name", arg) in let bnds = bnd :: bnds in
  OCaml.VDict bnds
and vof_func_def {
                 f_ref = v_f_ref;
                 f_name = v_f_name;
                 f_params = v_f_params;
                 f_return_type = v_f_return_type;
                 f_body = v_f_body;
                 f_kind = v_f_type;
                 m_modifiers = v_f_modifiers;
                 f_attrs = v_f_attrs;
                 l_uses = v_l_uses;
               } =
  let bnds = [] in
  let arg = OCaml.vof_list vof_stmt v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_attribute v_f_attrs in
  let bnd = ("f_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_lexical_var v_l_uses in
  let bnd = ("l_uses", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_modifier v_f_modifiers in
  let bnd = ("m_modifiers", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_hint_type v_f_return_type in
  let bnd = ("f_return_type", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_bool v_f_ref in
  let bnd = ("f_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_parameter v_f_params in
  let bnd = ("f_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_function_type v_f_type in
  let bnd = ("f_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrapped_string v_f_name in
  let bnd = ("f_name", arg) in
  let bnds = bnd :: bnds in
  OCaml.VDict bnds
and vof_lexical_var (is_ref, name) =
  OCaml.VTuple ([OCaml.vof_bool is_ref; vof_var name])
and vof_function_type =
  function
  | Function -> OCaml.VSum (("Function", []))
  | Method -> OCaml.VSum (("Method", []))
  | AnonLambda -> OCaml.VSum (("AnonLambda", []))
  | ShortLambda -> OCaml.VSum (("ShortLambda", []))
and
  vof_parameter {
                  p_attrs = v_p_attrs;
                  p_type = v_p_type;
                  p_ref = v_p_ref;
                  p_name = v_p_name;
                  p_default = v_p_default;
                  p_variadic = v_p_variadic
                } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_expr v_p_default in
  let bnd = ("p_default", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_tok v_p_ref in
  let bnd = ("p_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_attribute v_p_attrs in
  let bnd = ("p_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_hint_type v_p_type in
  let bnd = ("p_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrapped_string v_p_name in
  let bnd = ("p_name", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_tok v_p_variadic in
  let bnd = ("p_variadic", arg) in
  let bnds = bnd :: bnds in
  OCaml.VDict bnds
and vof_hint_type =
  function
  | Hint v1 -> let v1 = vof_name v1 in OCaml.VSum (("Hint", [ v1 ]))
  | HintArray v1 -> let v1 = vof_tok v1 in OCaml.VSum (("HintArray", [v1]))
  | HintQuestion (tok, t) -> 
      let t = vof_hint_type t in
      let tok = vof_tok tok in
      OCaml.VSum (("HintQuestion", [ tok; t ]))
  | HintTuple l -> 
      let l = vof_bracket (OCaml.vof_list vof_hint_type) l in
      OCaml.VSum (("HintTuple", [l]))
  | HintCallback (args, ret) ->
      OCaml.VSum (("HintCallback",
                   [ OCaml.VList (List.map vof_hint_type args);
                     OCaml.vof_option vof_hint_type ret ]))
  | HintShape (t, v1) ->
      let t = vof_tok t in
      let v1 =
        vof_bracket (OCaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_expr v1
             and v2 = vof_hint_type v2
             in OCaml.VTuple [ v1; v2 ]))
          v1
      in OCaml.VSum (("HintShape", [ t; v1 ]))
  | HintTypeConst (v1, t, v2) ->
    let v1 = vof_hint_type v1
    and t = vof_tok t
    and v2 = vof_hint_type v2
    in OCaml.VSum (("HintTypeConst", [ v1; t; v2]))
  | HintVariadic (t, None) -> 
    let t = vof_tok t in
    OCaml.VSum (("HintVariadic", [t]))
  | HintVariadic (t, Some v1) -> 
    let t = vof_tok t in
    OCaml.VSum (("HintVariadic", [t;vof_hint_type v1]))

and
  vof_class_def {
                  c_kind = v_c_type;
                  c_modifiers = v_c_modifiers;
                  c_name = v_c_name;
                  c_extends = v_c_extends;
                  c_attrs = v_c_attrs;
                  c_xhp_fields = v_c_xhp_fields;
                  c_xhp_attr_inherit = v_c_xhp_attr_inherit;
                  c_uses = _v_c_traits;
                  c_implements = v_c_implements;
                  c_constants = v_c_constants;
                  c_variables = v_c_variables;
                  c_methods = v_c_body;
                  c_enum_type = v_c_enum_type;
                  c_braces = v_c_braces;
                } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_enum_type v_c_enum_type in
  let bnd = ("c_enum", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_method_def v_c_body in
  let bnd = ("c_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_class_var v_c_variables in
  let bnd = ("c_variables", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_xhp_field v_c_xhp_fields in
  let bnd = ("c_xhp_fields", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_class_name v_c_xhp_attr_inherit in
  let bnd = ("c_xhp_attr_inherit", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_constant_def v_c_constants in
  let bnd = ("c_constants", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_attribute v_c_attrs in
  let bnd = ("c_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_class_name v_c_implements in
  let bnd = ("c_implements", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_class_name v_c_extends in
  let bnd = ("c_extends", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_modifier v_c_modifiers in
  let bnd = ("c_modifiers", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_bracket OCaml.vof_unit v_c_braces in
  let bnd = ("c_braces", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap vof_class_type v_c_type in
  let bnd = ("c_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrapped_string v_c_name in
  let bnd = ("c_name", arg) in
  let bnds = bnd :: bnds in
  OCaml.VDict bnds
and
  vof_enum_type {
                 e_base = v_e_base;
                 e_constraint = v_e_constraint;
                } =
  let bnds = [] in
  let arg = vof_hint_type v_e_base in
  let bnd = ("e_base", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_hint_type v_e_constraint in
  let bnd = ("e_constraint", arg) in
  let bnds = bnd :: bnds in
  OCaml.VDict bnds
and vof_class_name x = vof_hint_type x
and vof_class_type =
  function
  | Class -> OCaml.VSum (("Class", []))
  | Interface -> OCaml.VSum (("Interface", []))
  | Trait -> OCaml.VSum (("Trait", []))
  | Enum -> OCaml.VSum (("Enum", []))
and vof_xhp_field (v1, v2) =
  let v1 = vof_class_var v1 in
  let v2 = OCaml.VBool v2 in
  OCaml.VSum (("Xhp_field", [ v1; v2 ]))
and
  vof_class_var {
                  cv_name = v_cv_name;
                  cv_type = v_cv_type;
                  cv_value = v_cv_value;
                  cv_modifiers = v_cv_modifiers
                } =
  let bnds = [] in
  let arg = OCaml.vof_list vof_modifier v_cv_modifiers in
  let bnd = ("cv_modifiers", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_expr v_cv_value in
  let bnd = ("cv_value", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_hint_type v_cv_type in
  let bnd = ("cv_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_var v_cv_name in
  let bnd = ("cv_name", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_modifier x = vof_wrap Ast_php.vof_modifier x
and vof_attribute v = vof_expr v
and vof_method_def x = vof_func_def x
and vof_pattern x = vof_expr x
and vof_array_value x = vof_expr x

let vof_any =
  function
  | Program v1 -> let v1 = vof_program v1 in OCaml.VSum (("Program", [ v1 ]))
  | Stmt v1 -> let v1 = vof_stmt v1 in OCaml.VSum (("Stmt", [ v1 ]))
  | Expr2 v1 -> let v1 = vof_expr v1 in OCaml.VSum (("Expr2", [ v1 ]))
  | Param v1 -> let v1 = vof_parameter v1 in OCaml.VSum (("Param", [ v1 ]))

(* very ugly, should have a real visitor_php_simple.ml *)
let toks_of_any any =
  Common.save_excursion visit_mode true (fun () ->
    visited_toks := [];
    let _ = vof_any any in
    let res = !visited_toks in
    visited_toks := [];
    res
  )
