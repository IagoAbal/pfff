(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Il_ruby

let vof_pos v = Meta_parse_info.vof_info_adjustable_precision v
let vof_big_int _x = OCaml.VUnit

let vof_t _f _set = OCaml.VUnit
let vof_t2 _strset = OCaml.VUnit
  
let rec vof_identifier =
  function
  | Var v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_var_kind v1
             and v2 = OCaml.vof_string v2
             in OCaml.VTuple [ v1; v2 ])
      in OCaml.VSum (("Var", [ v1 ]))
  | Self -> OCaml.VSum (("Self", []))
  | Scope ((v1, v2)) ->
      let v1 = vof_identifier v1
      and v2 = OCaml.vof_string v2
      in OCaml.VSum (("Scope", [ v1; v2 ]))
  | UScope v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("UScope", [ v1 ]))
  | Nil -> OCaml.VSum (("Nil", []))
  | True -> OCaml.VSum ((" True", []))
  | False -> OCaml.VSum ((" False", []))
and vof_var_kind =
  function
  | Local -> OCaml.VSum (("Local", []))
  | Instance -> OCaml.VSum (("Instance", []))
  | Class -> OCaml.VSum (("Class", []))
  | Global -> OCaml.VSum (("Global", []))
  | Constant -> OCaml.VSum (("Constant", []))
  | Builtin -> OCaml.VSum (("Builtin", []))
  
let vof_builtin_or_global (v1, v2) =
  let v1 = vof_var_kind v1
  and v2 = OCaml.vof_string v2
  in OCaml.VTuple [ v1; v2 ]
  
let rec vof_msg_id =
  function
  | ID_UOperator v1 ->
      let v1 = vof_unary_op v1 in OCaml.VSum (("ID_UOperator", [ v1 ]))
  | ID_Operator v1 ->
      let v1 = vof_binary_op v1 in OCaml.VSum (("ID_Operator", [ v1 ]))
  | ID_MethodName v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("ID_MethodName", [ v1 ]))
  | ID_Assign v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("ID_Assign", [ v1 ]))
  | ID_Super -> OCaml.VSum (("ID_Super", []))
and vof_unary_op =
  function
  | Op_UMinus -> OCaml.VSum (("Op_UMinus", []))
  | Op_UPlus -> OCaml.VSum (("Op_UPlus", []))
  | Op_UTilde -> OCaml.VSum (("Op_UTilde", []))
and vof_binary_op =
  function
  | Op_Plus -> OCaml.VSum (("Op_Plus", []))
  | Op_Minus -> OCaml.VSum (("Op_Minus", []))
  | Op_Times -> OCaml.VSum (("Op_Times", []))
  | Op_Rem -> OCaml.VSum (("Op_Rem", []))
  | Op_Div -> OCaml.VSum (("Op_Div", []))
  | Op_Pow -> OCaml.VSum (("Op_Pow", []))
  | Op_CMP -> OCaml.VSum (("Op_CMP", []))
  | Op_EQ -> OCaml.VSum (("Op_EQ", []))
  | Op_EQQ -> OCaml.VSum (("Op_EQQ", []))
  | Op_GEQ -> OCaml.VSum (("Op_GEQ", []))
  | Op_LEQ -> OCaml.VSum (("Op_LEQ", []))
  | Op_LT -> OCaml.VSum (("Op_LT", []))
  | Op_GT -> OCaml.VSum (("Op_GT", []))
  | Op_BAnd -> OCaml.VSum (("Op_BAnd", []))
  | Op_BOr -> OCaml.VSum (("Op_BOr", []))
  | Op_LShift -> OCaml.VSum (("Op_LShift", []))
  | Op_RShift -> OCaml.VSum (("Op_RShift", []))
  | Op_Match -> OCaml.VSum (("Op_Match", []))
  | Op_XOR -> OCaml.VSum (("Op_XOR", []))
  | Op_ARef -> OCaml.VSum (("Op_ARef", []))
  | Op_ASet -> OCaml.VSum (("Op_ASet", []))
  
let rec vof_expr =
  function
  | EId v1 -> let v1 = vof_identifier v1 in OCaml.VSum (("EId", [ v1 ]))
  | ELit v1 -> let v1 = vof_literal v1 in OCaml.VSum (("ELit", [ v1 ]))
and vof_literal =
  function
  | FixNum v1 -> let v1 = OCaml.vof_int v1 in OCaml.VSum (("FixNum", [ v1 ]))
  | BigNum v1 ->
      let v1 = vof_big_int v1 in OCaml.VSum (("BigNum", [ v1 ]))
  | Float ((v1, v2)) ->
      let v1 = OCaml.vof_string v1
      and v2 = OCaml.vof_float v2
      in OCaml.VSum (("Float", [ v1; v2 ]))
  | String v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("String", [ v1 ]))
  | Atom v1 -> let v1 = OCaml.vof_string v1 in OCaml.VSum (("Atom", [ v1 ]))
  | Regexp ((v1, v2)) ->
      let v1 = OCaml.vof_string v1
      and v2 = OCaml.vof_string v2
      in OCaml.VSum (("Regexp", [ v1; v2 ]))
  | Range ((v1, v2, v3)) ->
      let v1 = OCaml.vof_bool v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in OCaml.VSum (("Range", [ v1; v2; v3 ]))
  | Array v1 ->
      let v1 = OCaml.vof_list vof_star_expr v1
      in OCaml.VSum (("Array", [ v1 ]))
  | Hash v1 ->
      let v1 =
        OCaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_expr v1
             and v2 = vof_expr v2
             in OCaml.VTuple [ v1; v2 ])
          v1
      in OCaml.VSum (("Hash", [ v1 ]))
and vof_star_expr =
  function
  | SE v1 -> let v1 = vof_expr v1 in OCaml.VSum (("SE", [ v1 ]))
  | SStar v1 -> let v1 = vof_expr v1 in OCaml.VSum (("SStar", [ v1 ]))
  
let rec vof_tuple_expr =
  function
  | TTup v1 ->
      let v1 = OCaml.vof_list vof_tuple_expr v1
      in OCaml.VSum (("TTup", [ v1 ]))
  | TE v1 -> let v1 = vof_expr v1 in OCaml.VSum (("TE", [ v1 ]))
  | TStar v1 -> let v1 = vof_tuple_expr v1 in OCaml.VSum (("TStar", [ v1 ]))
  
let rec vof_lhs =
  function
  | LId v1 -> let v1 = vof_identifier v1 in OCaml.VSum (("LId", [ v1 ]))
  | LTup v1 ->
      let v1 = OCaml.vof_list vof_lhs v1 in OCaml.VSum (("LTup", [ v1 ]))
  | LStar v1 -> let v1 = vof_identifier v1 in OCaml.VSum (("LStar", [ v1 ]))

let rec
  vof_stmt {
             snode = v_snode;
             pos = v_pos;
             sid = v_sid;
             lexical_locals = v_lexical_locals;
             preds = v_preds;
             succs = v_succs
           } =
  let bnds = [] in
  let arg = vof_t vof_stmt v_succs in
  let bnd = ("succs", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_t vof_stmt v_preds in
  let bnd = ("preds", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_t2 v_lexical_locals in
  let bnd = ("lexical_locals", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_int v_sid in
  let bnd = ("sid", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_pos v_pos in
  let bnd = ("pos", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stmt_node v_snode in
  let bnd = ("snode", arg) in 
  let bnds = bnd :: bnds in 
  (* OCaml.VDict bnds *)
  ignore bnds;
  arg
  
and vof_stmt_node =
  function
  | I Expression v1 ->
      let v1 = vof_expr v1 in OCaml.VSum (("Expression", [ v1 ]))
  | I Assign ((v1, v2)) ->
      let v1 = vof_lhs v1
      and v2 = vof_tuple_expr v2
      in OCaml.VSum (("Assign", [ v1; v2 ]))
  | I Call ((v1, v2)) ->
      let v1 = OCaml.vof_option vof_lhs v1
      and v2 = vof_method_call v2
      in OCaml.VSum (("Call", [ v1; v2 ]))
  | Seq v1 ->
      let v1 = OCaml.vof_list vof_stmt v1 in OCaml.VSum (("Seq", [ v1 ]))
  | If ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("If", [ v1; v2; v3 ]))
  | While ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("While", [ v1; v2 ]))
  | For ((v1, v2, v3)) ->
      let v1 = OCaml.vof_list vof_block_formal_param v1
      and v2 = vof_expr v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("For", [ v1; v2; v3 ]))
  | Case v1 -> let v1 = vof_case_block v1 in OCaml.VSum (("Case", [ v1 ]))
  | Return v1 ->
      let v1 = OCaml.vof_option vof_tuple_expr v1
      in OCaml.VSum (("Return", [ v1 ]))
  | Yield ((v1, v2)) ->
      let v1 = OCaml.vof_option vof_lhs v1
      and v2 = OCaml.vof_list vof_star_expr v2
      in OCaml.VSum (("Yield", [ v1; v2 ]))
  | Break v1 ->
      let v1 = OCaml.vof_option vof_tuple_expr v1
      in OCaml.VSum (("Break", [ v1 ]))
  | Next v1 ->
      let v1 = OCaml.vof_option vof_tuple_expr v1
      in OCaml.VSum (("Next", [ v1 ]))
  | Redo -> OCaml.VSum (("Redo", []))
  | Retry -> OCaml.VSum (("Retry", []))
  | ExnBlock v1 ->
      let v1 = vof_exn_block v1 in OCaml.VSum (("ExnBlock", [ v1 ]))
  | Begin v1 -> let v1 = vof_stmt v1 in OCaml.VSum (("Begin", [ v1 ]))
  | End v1 -> let v1 = vof_stmt v1 in OCaml.VSum (("End", [ v1 ]))
  | D ModuleDef ((v1, v2, v3)) ->
      let v1 = OCaml.vof_option vof_lhs v1
      and v2 = vof_identifier v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("ModuleDef", [ v1; v2; v3 ]))
  | D ClassDef ((v1, v2, v3)) ->
      let v1 = OCaml.vof_option vof_lhs v1
      and v2 = vof_class_kind v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("ClassDef", [ v1; v2; v3 ]))
  | D MethodDef ((v1, v2, v3)) ->
      let v1 = vof_def_name v1
      and v2 = OCaml.vof_list vof_method_formal_param v2
      and v3 = vof_stmt v3
      in OCaml.VSum (("MethodDef", [ v1; v2; v3 ]))
  | D Defined ((v1, v2)) ->
      let v1 = vof_identifier v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("Defined", [ v1; v2 ]))
  | D Alias v1 -> let v1 = vof_alias_kind v1 in OCaml.VSum (("Alias", [ v1 ]))
  | D Undef v1 ->
      let v1 = OCaml.vof_list vof_msg_id v1 in OCaml.VSum (("Undef", [ v1 ]))
and
  vof_method_call {
                    mc_target = v_mc_target;
                    mc_msg = v_mc_msg;
                    mc_args = v_mc_args;
                    mc_cb = v_mc_cb
                  } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_codeblock v_mc_cb in
  let bnd = ("mc_cb", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_star_expr v_mc_args in
  let bnd = ("mc_args", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_msg_id v_mc_msg in
  let bnd = ("mc_msg", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_expr v_mc_target in
  let bnd = ("mc_target", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_codeblock =
  function
  | CB_Arg v1 -> let v1 = vof_expr v1 in OCaml.VSum (("CB_Arg", [ v1 ]))
  | CB_Block ((v1, v2)) ->
      let v1 = OCaml.vof_list vof_block_formal_param v1
      and v2 = vof_stmt v2
      in OCaml.VSum (("CB_Block", [ v1; v2 ]))
and
  vof_exn_block {
                  exn_body = v_exn_body;
                  exn_rescue = v_exn_rescue;
                  exn_else = v_exn_else;
                  exn_ensure = v_exn_ensure
                } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_stmt v_exn_ensure in
  let bnd = ("exn_ensure", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_option vof_stmt v_exn_else in
  let bnd = ("exn_else", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_rescue_block v_exn_rescue in
  let bnd = ("exn_rescue", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stmt v_exn_body in
  let bnd = ("exn_body", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and
  vof_rescue_block {
                     rescue_guards = v_rescue_guards;
                     rescue_body = v_rescue_body
                   } =
  let bnds = [] in
  let arg = vof_stmt v_rescue_body in
  let bnd = ("rescue_body", arg) in
  let bnds = bnd :: bnds in
  let arg = OCaml.vof_list vof_rescue_guard v_rescue_guards in
  let bnd = ("rescue_guards", arg) in
  let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_rescue_guard =
  function
  | Rescue_Expr v1 ->
      let v1 = vof_tuple_expr v1 in OCaml.VSum (("Rescue_Expr", [ v1 ]))
  | Rescue_Bind ((v1, v2)) ->
      let v1 = vof_tuple_expr v1
      and v2 = vof_identifier v2
      in OCaml.VSum (("Rescue_Bind", [ v1; v2 ]))
and
  vof_case_block {
                   case_guard = v_case_guard;
                   case_whens = v_case_whens;
                   case_else = v_case_else
                 } =
  let bnds = [] in
  let arg = OCaml.vof_option vof_stmt v_case_else in
  let bnd = ("case_else", arg) in
  let bnds = bnd :: bnds in
  let arg =
    OCaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_tuple_expr v1
         and v2 = vof_stmt v2
         in OCaml.VTuple [ v1; v2 ])
      v_case_whens in
  let bnd = ("case_whens", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_expr v_case_guard in
  let bnd = ("case_guard", arg) in let bnds = bnd :: bnds in OCaml.VDict bnds
and vof_alias_kind =
  function
  | Alias_Method ((v1, v2)) ->
      let v1 = vof_msg_id v1
      and v2 = vof_msg_id v2
      in OCaml.VSum (("Alias_Method", [ v1; v2 ]))
  | Alias_Global ((v1, v2)) ->
      let v1 = vof_builtin_or_global v1
      and v2 = vof_builtin_or_global v2
      in OCaml.VSum (("Alias_Global", [ v1; v2 ]))
and vof_class_kind =
  function
  | MetaClass v1 ->
      let v1 = vof_identifier v1 in OCaml.VSum (("MetaClass", [ v1 ]))
  | NominalClass ((v1, v2)) ->
      let v1 = vof_identifier v1
      and v2 = OCaml.vof_option vof_identifier v2
      in OCaml.VSum (("NominalClass", [ v1; v2 ]))
and vof_def_name =
  function
  | Instance_Method v1 ->
      let v1 = vof_msg_id v1 in OCaml.VSum (("Instance_Method", [ v1 ]))
  | Singleton_Method ((v1, v2)) ->
      let v1 = vof_identifier v1
      and v2 = vof_msg_id v2
      in OCaml.VSum (("Singleton_Method", [ v1; v2 ]))
and vof_method_formal_param =
  function
  | Formal_meth_id v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("Formal_meth_id", [ v1 ]))
  | Formal_amp v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("Formal_amp", [ v1 ]))
  | Formal_star v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("Formal_star", [ v1 ]))
  | Formal_default ((v1, v2)) ->
      let v1 = OCaml.vof_string v1
      and v2 = vof_tuple_expr v2
      in OCaml.VSum (("Formal_default", [ v1; v2 ]))
and vof_block_formal_param =
  function
  | Formal_block_id ((v1, v2)) ->
      let v1 = vof_var_kind v1
      and v2 = OCaml.vof_string v2
      in OCaml.VSum (("Formal_block_id", [ v1; v2 ]))
  | Formal_star2 v1 ->
      let v1 = OCaml.vof_string v1 in OCaml.VSum (("Formal_star2", [ v1 ]))
  | Formal_tuple v1 ->
      let v1 = OCaml.vof_list vof_block_formal_param v1
      in OCaml.VSum (("Formal_tuple", [ v1 ]))
  
let vof_t v = vof_stmt v
  
let vof_any_formal =
  function
  | B v1 -> let v1 = vof_block_formal_param v1 in OCaml.VSum (("B", [ v1 ]))
  | M v1 -> let v1 = vof_method_formal_param v1 in OCaml.VSum (("M", [ v1 ]))
  
